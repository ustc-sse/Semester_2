高软总复习

##	1. 什么是软件, 画出 硬件失效曲线, 软件失效曲线, 给出简单解释

*	软件是按照特定顺序组织的数据结构, 指令和文档。

	软件可以分为系统软件和应用软件。

	软件是逻辑元素, 不会磨损。

	<br>

*	失效曲线

	![失效曲线](https://s2.ax1x.com/2019/07/09/Z6kejx.png)

*	硬件失效曲线

	初期失效率, 通常来自设计或生产缺陷

	平稳期, 缺陷纠正后, 失效率很低并保持平稳

	磨损期, 一段时间后开始磨损, 失效率再次提高

*	软件失效曲线

	理想曲线, 初期由于设计错误有较高失效率, 错误修复后, 因为软件不会磨损, 所以理想情况下失效率一直保持很低

	实际曲线, 软件会退化, 其根本原因是软件会面临变更, 每次变更都会引入新的错误, 导致失效率陡增。新的错误被修复后, 失效率会下降并且平缓, 但是比原来稳定的失效率更高, 因为软件变得更加复杂了。

<br>

##	2. 简述软件工程的"通用过程模型", 画出软件过程框架, 并解释

*	软件过程是在产品构建过程中所需完成的工作活动、动作、任务的集合。

	这些活动、动作、任务中的每一个都属于某一框架或者模型, 后者定义了他们与过程之间的关系。

	通用过程模型习惯上也称为软件开发模型, 它是软件开发全部过程、活动和任务的结构框架。

*	软件过程框架和过程流

	![](https://s2.ax1x.com/2019/07/09/Z6AYi4.png)

*	每个框架活动由一系列动作构成, 每个动作有任务集定义, 任务集明确了将任务、产品、质量保证点, 过程状态里程碑

	软件过程框架定义了五种框架活动：沟通、策划、建模、构建、部署。此外, 项目跟踪、风险管理、质量保障、技术评审也贯穿始终。

	https://blog.csdn.net/sinat_21107433/article/details/82846657

<br>

##	3. 请举出4个惯用的过程模型, 并对其中的一个模型 1). 画出示意图, 2). 简要说明工作流程,  3). 模型优缺点

*	过程模型：瀑布模型, V模型, 螺旋模型, 快速原型模型, 敏捷开发模型

*	瀑布模型

	![](https://s2.ax1x.com/2019/07/09/Z6Vput.png)

*	简述瀑布模型

	瀑布模型将软件生命周期划分为沟通和需求分析、策划、建模, 构建, 部署等过程, 它是一个线性模型, 各个过程之间的顺序是固定的。

*	优点

	稳定规范, 文档齐全, 质量有保证

*	缺点

	不够灵活, 开发过程不能逆转, 需要客户有明确的需求, 且中途不能变更

<br>

##	4. 什么是需求工程？有哪几项任务? 简述各项任务的主要内容

*	需求工程, 是定义、记录、理解和维护需求的过程, 它通过合适技术和方法帮助客户进行需求描述, 形成需求文档, 从而帮助设计者和开发者理解问题, 便于软件的设计, 实现和维护。

	需求工程有7项任务：起始, 获取, 细化, 协商, 规格说明, 确认, 需求管理

	起始：包括需求发现, 项目范围, 与相关人员的初步交流, 可行性分析等内容, 从而对项目建立基本的理解。

	获取：询问客户和用户对产品的目标, 他们想要实现什么功能, 产品如何用于日常工作, 从而建立商业目标。

	细化：扩展和提炼前两个阶段获得的信息, 得到精确的模型, 从而说明软件的功能、特征和信息。

	协商：与客户进行协商, 从而平衡业务资源。协商也会调整相互冲突的需求, 并给各种需求排序。

	规格说明：用术语或者标准化的文档描述需求模型与使用场景。

	确认：保证规格说明描述了所有的系统需求, 如果出现错误则需要纠正。

	需求管理：通过需求管理, 可以帮助项目组标识、控制和跟踪需求和需求变更。

<br>

##	5. 画出软件需求获取层次图, 并对每个层次进行简要说明

*	需求获取层次图

	![](https://s2.ax1x.com/2019/07/09/Z6MSJK.png)

*	业务需求：描述了客户对产品的目标需求

	用户需求：描述了用户在使用产品时, 能够完成的任务和功能。描述方式是用例文档或方案脚本。

	功能需求：定义了开发人员必须实现的软件功能。

	软件需求规格说明书还包括了非功能需求, 包括用户界面、性能要求等

<br>

##	6. 什么是UML？对于下面的UML图, 1) 解释各个符号的含义, 2) 写出代码框架

![](https://s2.ax1x.com/2019/07/09/Z6Q11O.png)

*	UML 是统一建模语言的缩写, 用于说明、可视化、构建和编写一个面向对象的软件。UML 主要使用图形符号来表示软件的架构和设计, UML可以有效帮助团队沟通

*	矩形框：类

	类框之间的连线：表示类之间的关系, [1---*]表示关联, 实线空心三角表示泛化（继承）, 虚线空心三角表示实现（接口）, 虚线箭头表示依赖（参数）

	一个顾客可以多次订票, 但每次订票只能由一个顾客来执行

	有两种订票方式, 套票和个人票

	每一张票要么是套票, 要么是个人票

	每一场演出有多张票可以预定, 每张票对应唯一一个座位号

	每一次show有多次演出, 每次演出用剧目

*	代码框架

	略

<br>

##	7. 画出聚合分解图, 第10次课补充材料

*	通过分解，可以把隐含关系（聚合和继承）清晰化，有利于整体设计。

*	先画出 A 和 C，菱形是包含（聚合），三角是继承（指向父类）

	```
	如图 2-13，就是 B 继承 A，C 继承 B，C 包含 A
	因此 2-13 分解过程如下
	1) 画出 C 包含 A （子类 C 包含父类 A ） 
	2) 因为 B 继承了 A，所以把 B 代到 A 里面，也就是画出 C 包含 B
	3) 同理，C 间接继承了 A，所以把 C 代到 A，也就是画出 C 包含 C

	2-14 分解过程
	1) 画出 A 包含 C （父类 A 包含子类 C ）
	2) 因为 B 继承了 A，所以把 B 代到 A 里面，也就是画出 B 包含 C
	3) 同理，C 间接继承了 A，所以把 C 代到 A，也就是画出 C 包含 C

	2-15 分解过程
	1) 画出 C 包含 A
	2) 因为 B 继承了 A，所以把 B 代到 A 里面，也就是画出 C 包含 B
	3) 由于 B 包含 C，所以画出 B 包含 C （子类 B 间接包含父类 A ）

	2-16 分解过程
	1) 画出 A 包含 C
	2) 因为 B 继承了 A，所以把 B 代到 A 里面，也就是画出 B 包含 C
	3) 由于 C 包含 B，所以画出 C 包含 B （父类 A 间接包含子类 B ）
	```

	![](https://s2.ax1x.com/2019/07/09/Z6UkIe.png)

<br>

##	8. UML与Java语言互相转换的表示

*	接口与实现

	![](https://s2.ax1x.com/2019/07/09/Z6GSJI.png)

*	单向关联

	![](https://s2.ax1x.com/2019/07/09/Z6GCSP.png)

*	双向关联

	![](https://s2.ax1x.com/2019/07/09/Z6GMlV.png)

*	聚合

	![](https://s2.ax1x.com/2019/07/09/Z6GsTH.png)

*	自反关联

	![](https://s2.ax1x.com/2019/07/09/Z6G6kd.png)

<br>

##	9. 分析建模

*	画出结构化分析模型的组成结构图

	面向对象分析模型的组成结构图

	需求分析元素图

	简要说明三张图之间的关系（第5次课补充材料, 教材P125）

	![](https://s2.ax1x.com/2019/07/09/Z6tMlt.png)

	这些都是需求建模的方法。

	结构化分析模型到核心是数据字典 Data Dictionary, 由此展开进行建模, 描述数据对象在系统中如何流动和处理。

	面向对象分析模型到核心是使用实例, 即用例Use Case。这种方法关注到是客户需求类之间的协作方式。

	需求分析元素图, 根据不同视角建立不同到模型, 如基于场景到模型、基于类的模型、...

<br>

##	10. 画出 yourdon 面向对象 OOA / OOD 模型示意图, 同时给出主要符号的一般描述（第6次课补充材料, 第1章引论P14-15）

*	OOA 面向对象分析

	![](https://s2.ax1x.com/2019/07/11/ZgzEhn.jpg)

*	OOD 面向对象设计

	![](https://s2.ax1x.com/2019/07/11/Zgzr4A.jpg)

*	符号描述

	![](https://s2.ax1x.com/2019/07/11/Z2SGVg.jpg)

<br>

##	11. 什么是 yourdon 面向对象软件工程方法中的EROI图？对11题图中的EROI图按照Yourdon方法进行描述

*	EROI 图可以用来标识服务和消息，评估方案的质量

<br>

##	12. 题图 a 表示的是一个操作系统的块处理示意图, 用 Z 形式化语言描述后得到图 b 和图 c

*	Z 语言是一种用数学符号来描述计算机系统的规范化语言, Z 语言是对目标软件的功能描述。

	https://blog.csdn.net/qq_15037231/article/details/60470500 

*	题图

	![](https://s2.ax1x.com/2019/07/10/ZgyH6U.jpg)

*	解释图b, c中的符号, 解释每一行形式化语言的语义

	![](https://s2.ax1x.com/2019/07/11/Z2FuGQ.jpg)

	RemoveBlock: 第1行，队列中必须至少有一个结点；第2行，head结点被移走；第3行，head被放到自由块的集合里面；第4行，新的块队列等于旧的块队列的尾部。

	AddBlock: 后置条件是块的集合被加入块队列的尾部，同时已用块和自由块的集合保持不变

<br>

##	13. 画出 Petri 网的基本组成符号, 说明含义, 解释题13中的 Petri 网所描述的电梯问题的运行流程, （第7次课, 形式化方法概述（java语言实现）, P155）

*	Petri 网用于解决定时问题，也可以用于性能评价、规格说明和设计。Petri 网包含四个部分：一组位置 P, 一组转换 T, 输入函数 I, 输出函数 O

	![](https://s2.ax1x.com/2019/07/11/ZgvOzV.jpg)

	```
	一组位置 P, {p1, p2, p3, p4}

	一组转换 T, {t1, t2}

	两个输入函数
	I(t1) = {p2, p4}
	I(t2) = {p2}

	两个输出函数
	O(t1) = {p1}
	O(t2) = {p3, p3}
	注意，有两个 p3, 是因为有2个箭头从 t2 指向 p3
	```

<br>

##	14. 写出常见的体系结构风格, 画出教材中的一种, 简要说明（第8次课, 第13章P189）

*	以数据为中心的体系结构

	![](https://s2.ax1x.com/2019/07/10/Z6Twgs.png)

	数据存储位于体系结构到中心，其他构件会经常访问该数据存储，并对其进行增删查改。

	以数据为中心的体系结构具有可集成性，且客户构件之间是独立运作的。

*	数据流体系结构

	![](https://s2.ax1x.com/2019/07/10/Z6TIDx.png)

*	面向对象体系结构

*	调用和返回体系结构

	层次体系结构

	![](https://s2.ax1x.com/2019/07/10/Z67erq.png)

<br>

##	15. 用变换规则从如下的 数据流图 Data Flow Diagram 导出 结构图 Structure Chart

*	题图

	![](https://s2.ax1x.com/2019/07/10/Z6HRXR.png)

*	步骤1：画出虚线，划分 传入部分A、中心加工T、传出部分E 的边界

*	步骤2：第一级分解，顶层（控制模块） + 第一层（输入模块、中心加工模块、传出模块）

	![](https://s2.ax1x.com/2019/07/10/ZcCDMV.png)

*	步骤3：第二级分解

	![](https://s2.ax1x.com/2019/07/10/ZcPopn.png)

*	步骤4：合并

	![](https://s2.ax1x.com/2019/07/10/Zcig3R.png)

<br>

##	16. 利用变换规则导出下图的 SC 图，第9次课补充, 面向行为的设计

*	题图（抽象与实例）

	![]()

*	步骤1：对DFD进行分解，划分输入输出抽象点（输入模块，转换模块，输出模块）

*	步骤2：第一次求精和第二次求精

	![](https://s2.ax1x.com/2019/07/10/ZcmO7q.png)

<br>

##	17. 什么是OCP, 举例说明（第9次课, 第14章构建级设计, P212, 补充, 开闭原则和依赖倒置的例子, java）

*	构建设计基本的原则：开闭原则，Liskov替换原则，依赖倒置原则，接口分离原则

*	`Open-Closed Principle`, 开闭原则，模块（构件）应该对外延具有开放性，对修改具有封闭性。也就是说，无需对构件内部代码或逻辑进行修改就可以进行扩展。比如用很多到 `if-else` 逻辑的代码就不符合开闭原则，因为要增加逻辑的时候要增加更多的 `if-else`

	OCP 和依赖倒置的核心思想是面向接口编程

*	例子：没有使用 OCP 和依赖倒置

	```java
	// Person 是一个业务主类，不能经常修改
	// 如果参数定义成 Book 类，则与 Book 太耦合了
	// 也就是说，换成 Newspaper 就不能 read 了

	class Book{
		String getContent(){
			return "blablabla";
		}
	}
	class Person{
		void read(Book book){
			System.out.println(book.getContent());
		}
	}
	class Main{
		Person person = new Person();
		person.read(new Book());
	}
	```

*	例子：使用OCP和依赖倒置，面向接口编程

	```java
	interface ReadItem{
		String getContent();
	}
	class Book implements ReadItem{
		String getContent(){
			return "this is a book";
		}
	}
	class Newspaper implements ReadItem{
		String getContent(){
			return "Newspaper";
		}
	}
	class Person{
		// 参数换成接口类
		void read(ReadItem readitem){
			System.out.println(readitem.getContent());
		}
	}
	class Main{
		Person person = new Person();
		// Book 和 Newspaper 都可以读了
		person.read(new Book());
		person.read(new Newspaper());
	}
	```

<br>

##	18. 什么是设计模式 Design pattern ？画出某一设计模式的结构图（简单工厂，工厂方法, 抽象工厂, 装饰者, ）, 代码框架, 使用场景

*	设计模式是针对某些问题的最佳实践和解决方案，是指导思路和参考样板，是众多开发人员经过长时间的试错和总结得出的。

*	简单工厂 结构图

	![](https://s2.ax1x.com/2019/07/10/ZgswGV.png)

*	简单工厂代码框架

	```java
	// 1. 创建一个接口
	interface Shape{
		void draw();
	}

	// 2. 实现接口，得到矩形类
	class Rectangle implements Shape{
		@Override
		public void draw(){
			System.out.println("draw a rectangle");
		}
	}
	// 实现接口，得到圆形类
	class Circle implements Shape{
		@Override
		public void draw(){
			System.out.println("draw a circle");
		}
	}

	// 3. 创建工程, 基于参数信息，生成并返回实例对象
	class ShapeFactory{
		public Shape getShape(String shapeType){
			if( shapeType == null ){
				return null;
			}
			else if( shapeType.equals("Circle") ){
				return new Circle();
			}
			else if( shapeType.equals("Rectangle") ){
				return new Rectangle();
			}
			else{
				return null;
			}
		}
	}
	// 4. 使用测试
	public class Main{
		public static void main(String args[]) {
			ShapeFactory factory = new ShapeFactory();
			try{
				Shape shape = factory.getShape("circle");
				shape.draw();
				shape = factory.getShape("rectangle");
				shape.draw();
				shape = factory.getShape("biubiubiu");
				shape.draw();
			}
			catch( NullPointerException e ){
				System.out.println("没有这种形状");
			}
		}
	}
	```

*	简单工厂场景

	*	工厂类负责创建的对象（具体产品）比较少时。

	*	客户只知道传入工厂类的参数，对于如何创建对象不关心：

<br><br><br>

测试, 30分~40分

##	19. 由代码段画出流程图, 并给出判定覆盖的测试用例（判定条件）

*	代码段和流程图

	```pascal
	Procedure Example(A, B: REAL; VAR X:REAL);
	BEGIN
		IF (A > 1) AND (B = 0)
		THEN X := X/A;

		IF (A = 2) OR (X > 1)
		THEN X := X + 1;
	END
	```

	![](https://s2.ax1x.com/2019/07/10/ZcrGaq.png)

*	覆盖标准

	语句覆盖：选择足够多的测试数据，使被测程序中每个语句至少执行一次( A=2, B＝0, X=4), 语句覆盖对程序的逻辑覆盖很少

	判定覆盖：又叫分支覆盖，不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次（比语句覆盖多一些测试数据）

*	判定覆盖的测试用例

	```
	开始: s
	第一处判断：a/ac
	第二处判断: bd/bed

	若第一次覆盖了 a, 则第二次不需要再重复覆盖 a, 直接选 ac 就可以了, 这样可以得到最少的测试用例
	因此可以得到这样到覆盖路径 ( i 和 ii 的顺序可以互换 )
	i)  s-a-bd
	ii) s-ac-bed
	// 此时不需要再来 iii) s-a-bed 和 iv) s-ac-bd

	或者
	i)  s-a-bed
	ii) s-ac-bd

	因此下面两组测试数据就可做到判定覆盖
	I)  A=3, B=0, X=3   (覆盖 s-ac-bd)
	II) A=2, B=1, X=1   (覆盖 s-a-bed)

	这样，每一处判断到所有分支都测试过了
	```

<br>

##	20.	根据题图, i)根据标注点, 画出流图. ii)给出流图的环路复杂性. iii)给出独立路径

*	题图和流图

	![](https://s2.ax1x.com/2019/07/10/ZccD1K.png)

*	环路复杂性 V(G)

	```
	V(G) = 17(边数) - 13(结点数) + 2 = 6
	V(G) = 5(判定结点数) + 1 = 6
	```

*	独立路径

	```
	独立路径数量 = V(G)
	路径1：1 - 2 - 10 - 11 - 13
	路径2：1 - 2 - 10 - 12 - 13
	路径3：1 - 2 - 3 - 10 - 11 - 13

	注意：独立路径要求在定义该路径存在其他路径没有到过的边，因此
	`1 - 2 - 3 - 10 - 12 - 13` 不是一条新的独立路径，因为路径上所有的边都已经在之前的独立路径中遍历过了

	路径4：1 - 2 - 3 - 4 - 5 - 8 - 9 - 2 - ...
	路径5：1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 - 2 - ...
	路径6：1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 2 - ...
	```

<br>

##	21. 等价类测试电话号码（12次课, 黑盒测试等价类补充）

*	软件测试

	![](https://s2.ax1x.com/2019/07/10/ZgPD8s.png)

	黑盒测试：以程序的功能作为依据，根据功能说明书进行测试

	白盒测试：以程序的结构作为依据，又称为结构测试

*	黑盒测试 --- 等价分类法：程序输入可以分为很多个区间，使用每个其中的用例代表这个区间，以减少总的测试次数。

*	电话号码

	![](https://s2.ax1x.com/2019/07/10/ZgEzuR.png)

<br>

##	22. 因果图法（饮料, 电费, 第12次课, 两个补充举例）

*	因果图法，就是用图解的方法表示输入的各种组合关系，写出判定表，从而设计相应的测试用例。

*	电费

	![](https://s2.ax1x.com/2019/07/11/Z2iODx.png)

*	可乐

	![](https://s2.ax1x.com/2019/07/11/Z2ifbV.png)

<br>

##	23. 评审技术，缺陷的放大和消除

*	错误和成本计算

	![](https://s2.ax1x.com/2019/07/10/Zg3i1x.png)

<br>

##	24. 基于功能点的度量（14次课, 第30章产品度量, P487）

*	功能点 FP 度量可以 a). 估算开销和工作量. b). 预测错误数. c). 预测构件数和代码行数

*	信息域值：外部输入数(EI)，外部输出数(EO)，外部查询数(EQ)，内部逻辑文件数(ILF)，外部接口文件数(EIF)

	![](https://s2.ax1x.com/2019/07/10/ZgtWXq.jpg)

<br>

##	25. 什么是边界条件测试法？给出4种二维边界条件测试法的名称并画出示意图, （12次课补充, 软件测试与质量保证05）

*	边界条件法是对等价类法的扩展，根据经验，大量错误会发生在边界条件上，因此，针对等价类的边界条件设计一些测试用例，更容易发现软件的缺陷。

*	四种二维边界条件测试法：

	一般边界条件法（2 * 2 * n + 1 = 4n + 1 个测试用例）

	健壮边界条件法（2 * 3 * n + 1 = 6n + 1 个测试用例）

	最坏边界条件法（5^n 个测试用例）

	健壮最坏边界条件法（7^n 个测试用例）

	![](https://s2.ax1x.com/2019/07/10/ZgUDJg.jpg)

<br>